water <- watersheds$water[watersheds$stream==stream_name]
wetland <- watersheds$wetland[watersheds$stream==stream_name]
other <- watersheds$other[watersheds$stream==stream_name]
})
#Get the raw daily loads at each site
daily_load = data.frame()
for( raw_load_file in get(stream_name, pos=raw_load_files)) {
raw_path = paste("../data/", raw_load_file, sep="")
daily_load = rbind(daily_load, read.table(raw_path, na.strings=c("", "99999", "-1.23E+25"), header=TRUE))
}
daily_load$date = with(daily_load, as.POSIXlt(as.character(date), format="%m/%d/%Y"))
daily_load_data[[stream_name]] = daily_load
#Find the base flow that immediately preceded each event
antecedent_qbase = rep(NA, length(stream$start_day))
for( i in 1:length(antecedent_qbase) ) {
#get the date just prior to row i (subtraction is in units of seconds)
unmatched = identical(which( daily_flow$DV_date == stream$start_day[i]-86400 ), integer(0))
antecedent_qbase[i] = ifelse(unmatched, NA, daily_flow[which( daily_flow$DV_date == stream$start_day[i]-86400 ), 'QGW_fixed']) }
stream$antecedent_qbase = antecedent_qbase
flow_cdf[[stream_name]] = ecdf(antecedent_qbase)
stream$antecedent_qbase_quantile = flow_cdf[[stream_name]](antecedent_qbase)
stream$antecedent_qbase2 = antecedent_qbase / watersheds$area[watersheds$stream==stream_name]
#Find the average air temperature in the days before the event:
#first, read the raw air temperature data
nws = data.frame()
for( nws_file in get(stream_name, pos=nws_files)) {
nws_path = paste("../data/", nws_file, sep="")
nws = rbind(nws, read.csv(nws_path, na.strings=c("", "99999", "-1.23E+25", "null"), header=TRUE))
}
nws$date = with(nws, ISOdate(year=year, month=month, day=day))
#Now find the antecedent air temperature for each event
#We will compute the mean, min, and range of air temps before this event began.
antecedent_tmean = rep(NA, length(stream$start_day))
antecedent_trange = rep(NA, length(stream$start_day))
antecedent_tmax = rep(NA, length(stream$start_day))
period = 2 #how far back in days to do the averaging
for(i in 1:length(antecedent_tmean)) {
to_average = which(nws$date < stream$start_day[i] & nws$date >= stream$start_day[i] - period*86400)
antecedent_tmean[i] = mean(nws$Tmean[to_average], na.rm=TRUE)
antecedent_tmax[i] = max(nws$Tmean[to_average], na.rm=TRUE)
antecedent_trange[i] = diff(range(nws$Tmean[to_average], na.rm=TRUE))
}
stream$antecedent_tmean = antecedent_tmean
stream$antecedent_tmax = ifelse(antecedent_tmax>-Inf, antecedent_tmax, NA)
stream$antecedent_trange = ifelse(antecedent_trange>-Inf, antecedent_trange, NA)
#Now add this stream's data to the frame.
assign(stream_name, stream)
assign(paste(stream_name, "_flow", sep=""), daily_flow)
}
#Now mark the class of each event (1:snowmelt-driven, 2:pre-vegetation, 3:post-vegetation)
#We will gather all the data into one frame:
aggregate = data.frame()
#loop through the stream sites:
for(stream_name in streams)
{
stream = get(stream_name)
#Decide which events are snowmelt-driven:
class = vector()
prev_class = 0
num_events = dim(stream)[1]
#loop through the events
for(row in 1:num_events) {
#first look for the beginning of each year's snowmelt events
if(stream$m[row]=='M') {
class = c(class, 1)
prev_class = 1
}
else if(prev_class==1 & (stream$month[row]>=10 | stream$julian[row]<=135)) {
class = c(class, 1)
prev_class = 1
}
else {
class = c(class, 3)
prev_class = 3
}
}
#New way of separating the rainfall-driven and snowmelt-driven events, based on Mari's categories:
stream$snow = ifelse(stream$event_type==1, 0, 1)
assign(stream_name, stream)
assign(paste(stream_name, "_nosnow", sep=""), stream[stream$snow==FALSE,])
assign(paste(stream_name, "_snow", sep=""), stream[stream$snow==TRUE,])
aggregate = rbind(aggregate, stream)
aggregate$stream = rep("aggregate", dim(aggregate)[1])
aggregate_nosnow = aggregate[aggregate$snow==FALSE,]
aggregate_snow = aggregate[aggregate$snow==TRUE,]
}
@
<<bubble_function>>=
bubble <- function(target, scale=0.25, fg="red", bg="red", cex.lab=1.5, cex.axis=2, cex.title=1.5, line.xaxis=1, las=0) {
#The "_nosnow" dataframes exclude the snowfall-influenced events.
num_rows = ceiling(length(streams)/2)
layout(matrix(1:(2*num_rows), num_rows, 2))
par(mar=c(3,2,1,1)+0.1, oma=c(3,4,1,1), ann=FALSE)
for(stream_name in streams) {
#Retrieve the data frame for this stream
stream = get(stream_name)
#Produce the bubble plots
symbols(stream[stream$snow==FALSE,]$antecedent_qbase,
stream[stream$snow==FALSE,]$theisen,
circles=sqrt(stream[stream$snow==FALSE,target]),
inches=scale, fg=fg, bg=bg, bty='n',
xlim=c(0, max(stream$antecedent_qbase, na.rm=TRUE)*1.2),
ylim=c(0, max(stream$theisen, na.rm=TRUE)*1.2),
xaxt='n', yaxt='n')
axis(side=1, cex.axis=cex.axis, las=las, mgp=c(3,line.xaxis,0))
axis(side=2, cex.axis=cex.axis, las=las)
mtext(stream_names[[stream_name]], side=3, line=-9, cex=cex.title,
at=0.75*max(stream$antecedent_qbase, na.rm=TRUE) )
}
mtext("Antecedent baseflow (Cfs[?])", side=1, line=1, cex=cex.lab, at=NA, outer=TRUE)
mtext("Theisen rainfall (in)", side=2, line=2, cex=cex.lab, at=NA, outer=TRUE)
}
@
<<function_definitions>>=
#Import the GAM library
library(mgcv)
#Backslash-escape special characters.
sanitize <- function(str)
gsub('([#$%&~_\\^\\\\{}])', '\\\\\\1', str, perl=TRUE)
#Double-backslash-escape special characters.
sanitize2 <- function(str)
gsub('([#$%&~_\\^\\\\{}])', '\\\\\\\\\\1', str, perl=TRUE)
#Paste together a list of strings, backslash-escaping special characters in each one.
sanipaste <- function(pastelist, ...)
paste(sanitize(pastelist), ...)
#Paste together a list of strings, double-backslash-escaping special characers in each one.
sanipaste2 <- function(pastelist, ...)
paste(sanitize2(pastelist), ...)
#Determine what proportion of loadings comes from each event class
proportions <- function(streams, target, col.names) {
result = matrix( nrow=length(streams), ncol=length(col.names))
for(i in 1:length(streams)) {
stream = get(streams[i])
result[i,] = sapply(c(TRUE, FALSE), function(x) sum(stream[stream$snow==x, target], na.rm=T) / sum(stream[,target], na.rm=T))
}
result = data.frame(result)
names(result) = col.names
row.names(result) = sapply(streams, function(x) get(x=x, pos=stream_names))
return(result)
}
#Determine what percentage of loadings comes from each event class
percentages <- function(streams, target, col.names, decimals=1) {
props = proportions(streams, target, col.names)
result = matrix( nrow=0, ncol=length(col.names) )
rows = dim(props)[1]
for(row in 1:rows) {
result = rbind( result, paste( ifelse(round(props[row,]*100, decimals)%%1 == 0 & decimals > 0,
paste(as.character( round(props[row,]*100, 0) ), ".0", sep=""),
as.character( round(props[row,]*100, decimals) )), "%", sep="" ))
}
result=data.frame(result)
names(result) = names(props)
row.names(result) = row.names(props)
return(result)
}
#Extracts the terms in the model formula.
parse_args <- function(model)
return(attr(model$model, 'names'))
#Compute the model's R**2.
r2 <- function(model) {
actual = model$residual+model$fitted
rss = sum(model$residual**2)
tss = sum((actual-mean(actual))**2)
return(1 - rss/tss)
}
#Adds variables one-by-one to the model, finding the R^2 at each step.
r2_step <- function(model, variables, data) {
output = attr(model$model, "names")[1]
call = paste(output, "~", variables[1], sep="")
r_square = vector()
for(variable in variables[-1]) {
f = as.formula(call)
model = lm(formula=f, data=data)
r_square = c(r_square, r2(model))
call = paste(call, "+", variable)
}
model = update(model, formula=call)
r_square = c(r_square, r2(model))
return(r_square)
}
#This function uses the BIC to screen variables, returning the 'step' object.
stepwise_BIC <- function(target, data, sites) {
predictors_raw = c("num_events", "theisen", "p5max", "p10max", "p15max", "p30max", "p60max",
"ei", "duration", "ap_1day", "ap_3day", "ap_5day", "tmax", "tmean", "tmin", "antecedent_qbase_quantile",
"nws_prec", "nws_snow", "melt_snow", "cos_julian", "sin_julian",
"antecedent_tmean", "antecedent_tmax", "antecedent_trange", "slope", "area")
d = data[,c(target, predictors_raw)]
result = list()
predictors = c(predictors_raw, "slope:theisen", "slope:antecedent_qbase_quantile", "slope:duration", "slope:area")
full_model = as.formula( paste(target, "~", paste(predictors, collapse="+")) )
intercept_only = as.formula( paste(target, "~1") )
fm1 <- lm(full_model, data=d, x=T)
d = data.frame(cbind(target=fm1$fitted+fm1$residual, fm1$x))
names(d)[1] = target
fm2 <- lm(intercept_only, data=d)
screened = step(fm2, scope=full_model, direction='both', k=log(dim(d)[1]), trace=FALSE)
terms = parse_args(screened)
target = terms[1]
predictors = terms[-1]
formula = as.formula(paste(target, "~", paste(predictors, collapse="+")))
model = lm(formula, data=data, x=T)
#Put the results in a list object
result$site = sites[[as.character(unique(data$stream)[1])]]
result$model = model
result$ranked = names(model$model)[-1] # rank_predictors(model)
result$R2 = r2_step(model, result$ranked, data)
return(result)
}
#Use the BIC to screen the predictors that are available when snow is on the ground.
stepwise_BIC_snow <- function(target, data, sites) {
predictors_raw = c("num_days", "tmax", "tmean", "tmin", "nws_prec", "nws_snow", "antecedent_qbase_quantile",
"cos_julian", "sin_julian", "antecedent_tmean", "antecedent_tmax", "antecedent_trange", "slope", "area")
d = data[,c(target, predictors_raw)]
result = list()
predictors = c(predictors_raw, "slope:nws_prec", "slope:antecedent_qbase_quantile","slope:area")
full_model = as.formula( paste(target, "~", paste(predictors, collapse="+")) )
intercept_only = as.formula( paste(target, "~1") )
fm1 <- lm(full_model, data=d, x=T)
d = data.frame(cbind(target=fm1$fitted+fm1$residual, fm1$x))
names(d)[1] = target
fm2 <- lm(intercept_only, data=d)
screened = step(fm2, scope=full_model, direction='both', k=log(dim(d)[1]), trace=FALSE)
terms = parse_args(screened)
target = terms[1]
predictors = terms[-1]
formula = as.formula(paste(target, "~", paste(predictors, collapse="+")))
model = lm(formula, data=data, x=T)
#Put the results in a list object
result$site = sites[[as.character(unique(data$stream)[1])]]
result$model = model
result$ranked = names(model$model)[-1] #rank_predictors(model)
result$R2 = r2_step(model, result$ranked, data)
return(result)
}
#Use the BIC to screen the predictors that are available when snow is on the ground.
stepwise_BIC_snow2 <- function(target, data, sites) {
predictors_raw = c("num_days", "tmax", "tmean", "tmin", "nws_prec", "nws_snow", "total_water", "melt_water", "slope", "area", "antecedent_qbase_quantile",
"cos_julian", "sin_julian", "antecedent_tmean", "antecedent_tmax", "antecedent_trange")
d = data[,c(target, predictors_raw)]
result = list()
predictors = c(predictors_raw, "antecedent_qbase_quantile:slope", "antecedent_qbase_quantile:area", "total_water:slope", "total_water:area")
full_model = as.formula( paste(target, "~", paste(predictors, collapse="+")) )
intercept_only = as.formula( paste(target, "~1") )
fm1 <- lm(full_model, data=d, x=T)
d = data.frame(cbind(target=fm1$fitted+fm1$residual, fm1$x))
names(d)[1] = target
fm2 <- lm(intercept_only, data=d)
screened = step(fm2, scope=full_model, direction='both', k=log(dim(d)[1]), trace=FALSE)
terms = parse_args(screened)
target = terms[1]
predictors = terms[-1]
formula = as.formula(paste(target, "~", paste(predictors, collapse="+")))
model = lm(formula, data=data, x=T)
#Put the results in a list object
result$site = sites[[as.character(unique(data$stream)[1])]]
result$model = model
result$ranked = names(model$model)[-1] #rank_predictors(model)
result$R2 = r2_step(model, result$ranked, data)
return(result)
}
#Function to flag the largest observations of a certain variable.
major <- function(data, target, q=0.9, strata='') {
#Flag the major events within each level of strata
if(strata != '') {
major = rep(0, length(data[,target]))
#Loop through the strata
for(stratum in unique(data[,strata])) {
indx = which(data[,strata]==stratum)
major[indx] = ifelse(data[indx,target] > quantile(data[indx,target], q, na.rm=TRUE), 1, 0)
}
}
else {
#If no stratification is provided, then just flag the overall major events
major = ifelse(data[,target]>quantile(data[,target], q, na.rm=TRUE), 1, 0)
}
#Either way, return the result
return(major)
}
#Produce a boxplot of the per-event loading, showing rainfall- and snowmelt-driven events separately.
bplot <- function(formula, data, loc, classes, site, ylim, horizontal=FALSE, site.names=TRUE, ...) {
boxplot(formula, data=data, bty='n', ylim=ylim, cex=0.6, pch=4, horizontal=horizontal,
boxwex=0.4, frame.plot=F, ann=F, names=classes, add=T, at=loc:(loc+1), yaxt='n', xaxt='n', ...)
if (site.names)
mtext(site, side=2, line=6.5, at=(loc+0.5), las=1, cex=0.9, adj=0)
target = as.character(formula)[2]
target = paste(strsplit(target, "_", fixed=TRUE)[[1]][2], "_tot", sep="")
mtext( paste(round(100*sum(data[data$snow==0,target], na.rm=TRUE)/sum(data[,target], na.rm=TRUE), 0), "%", sep=""), side=4, line=1.2, at=loc, las=1, adj=1 )
mtext( paste(round(100*sum(data[data$snow==1,target], na.rm=TRUE)/sum(data[,target], na.rm=TRUE), 0), "%", sep=""), side=4, line=1.2, at=(loc+1), las=1, adj=1 )
}
#Produce a table that shows how the R**2 grows as new variables are added to the model.
R2_table <- function(varlist) {
numvars = length(varlist$R2)
cat(paste("\\multirow{", as.character(numvars+1), "}{*}{", varlist$site, "}", sep=""))
for(i in 1:numvars) {
cat(paste(" & ", as.character(round(varlist$R2[i], 3)), " & ", sep=""))
for(j in 1:i) {
cat(sanitize(varlist$ranked[j]))
if(j<i)
cat(" + ")
}
cat("\\\\ \n")
}
cat("\\vspace{2mm}\\\\ \n")
}
@
<<variable_selection_nosnow>>=
es = stepwise_BIC(target="log_stot_yield", data=eagle_nosnow, sites=stream_names)
js = stepwise_BIC(target="log_stot_yield", data=joosvalley_nosnow, sites=stream_names)
os = stepwise_BIC(target="log_stot_yield", data=otter_nosnow, sites=stream_names)
bs = stepwise_BIC(target="log_stot_yield", data=brewery_nosnow, sites=stream_names)
gs = stepwise_BIC(target="log_stot_yield", data=garfoot_nosnow, sites=stream_names)
ks = stepwise_BIC(target="log_stot_yield", data=kuenster_nosnow, sites=stream_names)
rs = stepwise_BIC(target="log_stot_yield", data=rattlesnake_nosnow, sites=stream_names)
bows = stepwise_BIC(target="log_stot_yield", data=bower_nosnow, sites=stream_names)
as = stepwise_BIC(target="log_stot_yield", data=aggregate_nosnow, sites=stream_names)
ep = stepwise_BIC(target="log_ptot_yield", data=eagle_nosnow, sites=stream_names)
jp = stepwise_BIC(target="log_ptot_yield", data=joosvalley_nosnow, sites=stream_names)
op = stepwise_BIC(target="log_ptot_yield", data=otter_nosnow, sites=stream_names)
bp = stepwise_BIC(target="log_ptot_yield", data=brewery_nosnow, sites=stream_names)
gp = stepwise_BIC(target="log_ptot_yield", data=garfoot_nosnow, sites=stream_names)
kp = stepwise_BIC(target="log_ptot_yield", data=kuenster_nosnow, sites=stream_names)
rp = stepwise_BIC(target="log_ptot_yield", data=rattlesnake_nosnow, sites=stream_names)
bowp = stepwise_BIC(target="log_ptot_yield", data=bower_nosnow, sites=stream_names)
ap = stepwise_BIC(target="log_ptot_yield", data=aggregate_nosnow, sites=stream_names)
@
<<variable_selection_snow>>=
es_snow = stepwise_BIC_snow(target="log_stot_yield", data=eagle_snow, sites=stream_names)
js_snow = stepwise_BIC_snow(target="log_stot_yield", data=joosvalley_snow, sites=stream_names)
os_snow = stepwise_BIC_snow(target="log_stot_yield", data=otter_snow, sites=stream_names)
bs_snow = stepwise_BIC_snow(target="log_stot_yield", data=brewery_snow, sites=stream_names)
gs_snow = stepwise_BIC_snow(target="log_stot_yield", data=garfoot_snow, sites=stream_names)
ks_snow = stepwise_BIC_snow(target="log_stot_yield", data=kuenster_snow, sites=stream_names)
rs_snow = stepwise_BIC_snow(target="log_stot_yield", data=rattlesnake_snow, sites=stream_names)
bows_snow = stepwise_BIC_snow(target="log_stot_yield", data=bower_snow, sites=stream_names)
as_snow = stepwise_BIC_snow(target="log_stot_yield", data=aggregate_snow, sites=stream_names)
ep_snow = stepwise_BIC_snow(target="log_ptot_yield", data=eagle_snow, sites=stream_names)
jp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=joosvalley_snow, sites=stream_names)
op_snow = stepwise_BIC_snow(target="log_ptot_yield", data=otter_snow, sites=stream_names)
bp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=brewery_snow, sites=stream_names)
gp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=garfoot_snow, sites=stream_names)
kp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=kuenster_snow, sites=stream_names)
rp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=rattlesnake_snow, sites=stream_names)
bowp_snow = stepwise_BIC_snow(target="log_ptot_yield", data=bower_snow, sites=stream_names)
ap_snow = stepwise_BIC_snow(target="log_ptot_yield", data=aggregate_snow, sites=stream_names)
@
<<variable_selection_snow2>>=
es_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=eagle_snow, sites=stream_names)
js_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=joosvalley_snow, sites=stream_names)
os_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=otter_snow, sites=stream_names)
bs_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=brewery_snow, sites=stream_names)
gs_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=garfoot_snow, sites=stream_names)
ks_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=kuenster_snow, sites=stream_names)
rs_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=rattlesnake_snow, sites=stream_names)
bows_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=bower_snow, sites=stream_names)
as_snow2 = stepwise_BIC_snow2(target="log_stot_yield", data=aggregate_snow, sites=stream_names)
ep_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=eagle_snow, sites=stream_names)
jp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=joosvalley_snow, sites=stream_names)
op_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=otter_snow, sites=stream_names)
bp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=brewery_snow, sites=stream_names)
gp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=garfoot_snow, sites=stream_names)
kp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=kuenster_snow, sites=stream_names)
rp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=rattlesnake_snow, sites=stream_names)
bowp_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=bower_snow, sites=stream_names)
ap_snow2 = stepwise_BIC_snow2(target="log_ptot_yield", data=aggregate_snow, sites=stream_names)
@
<<breakdown_snow_or_rain>>=
for(target in c('ptot_tot', 'pstorm_tot', 'stot_tot', 'sstorm_tot')) {
p = percentages(streams, target, col.names=c("snowmelt-driven", "rainfall-driven"), decimals=0)
pp = as.matrix( proportions(streams, target, col.names=c("snowmelt-driven", "rainfall-driven")) )
variable_name = paste(target, "_percentages", sep="")
variable_name2 = paste(target, "_proportions", sep="")
assign(variable_name, value=p)
assign(variable_name2, value=pp)
}
@
<<barchart, echo=FALSE, include=FALSE>>=
layout(matrix(1:4,2,2))
colors <- gray.colors(dim(ptot_tot_proportions)[1])
barplot(ptot_tot_proportions, beside=T, names.arg=c("snow","rain"), ylab="proportion of phosphorus")
barplot(stot_tot_proportions, beside=T, names.arg=c("snow","rain"), ylab="proportion of solids")
barplot(pstorm_tot_proportions, beside=T, names.arg=c("snow","rain"), ylab="proportion of phosphorus")
barplot(sstorm_tot_proportions, beside=T, names.arg=c("snow","rain"), ylab="proportion of solids")
legend(x="topleft", legend=streams, fill=colors, bty='n')
@
\begin{figure}[h!]
\begin{center}
<<fig2, fig=TRUE, fig.width=6, fig.height=8.5, include=TRUE>>=
<<barchart>>
@
\end{center}
\vspace{-10mm}
\caption{Cumulative storm loadings at the four creeks.\label{bars}}
\end{figure}
<<boxplots>>=
yy = c(-2.5, 2.8)
xx = c(2, 3*length(streams) + 1)
plot.new()
par(mfcol=c(1,2), mar=c(4, 4, 1, 1), oma=c(0,3,1,0))
plot.window(xlim=yy, ylim=xx)
par(mfg=c(1,1))
axis(side=1, cex=0.8)
title(xlab="log sediment yield (log tons / mi^2)", line=2.2, cex=0.8)
for(i in 1:length(streams))
{
#Put in the count of rainfall and snowmelt events
data = get(streams[i])
mtext(paste("Rainfall: ", length(data$snow)-sum(data$snow), sep=""), side=2, line=-1.7, at=3*i-0.1, las=1, adj=1, cex=0.8 )
mtext(paste("Snowmelt: ", sum(data$snow), sep=""), side=2, line=-1.7, at=(3*i+1.1), las=1, adj=1, cex=0.8 )
#Plot the boxplots of sediment yields
site = stream_names[[streams[i]]]
bplot(log_stot_yield~snow, data=data, loc=3*i, classes=c("snow","rain"), site=site, xlim=xx, ylim=yy, horizontal=TRUE, site.names=TRUE)
}
mtext("count:", side=3, line=0, at=yy[1], adj=0.6 )
mtext("proportion:", side=3, line=0, at=yy[2], adj=0.39 )
mtext("Sediment", side=3, line=0.8, at=mean(yy), cex=1.2 )
yy = c(-2.5, 3.1)
par(mfg=c(1,2), mar=c(4, 1.6, 1, 3.5), oma=c(0,0,1,1.5))
plot.window(xlim=yy, ylim=xx)
title(xlab="log phosphorus yield (log pounds / mi^2)", line=2.2, cex=0.8)
axis(side=1, cex=0.8)
for(i in 1:length(streams))
{
data = get(streams[i])
site = stream_names[[streams[i]]]
bplot(log_ptot_yield~snow, data=data, loc=3*i, classes=c("snow","rain"), site=site, xlim=xx, ylim=yy, horizontal=TRUE, site.names=FALSE)
}
mtext("proportion:", side=3, line=0, at=yy[2], adj=0.35 )
mtext("Phosphorus", side=3, line=0.8, at=mean(yy), cex=1.2 )
@
%Boxplots of the contribution from individual storm events
\begin{figure}[h]
\setkeys{Gin}{width=1\textwidth}    %make figures a bit wider than the Sweave default.
\begin{center}
<<show_boxplots, fig=TRUE, fig.width=9, fig.height=11, include=TRUE>>=
<<boxplots>>
@
\caption{Boxplots showing the sediment and phosphorus load produced by individual events at all four streams.\label{boxplots}}
\end{center}
\end{figure}
<<cumulative_loading_by_rainfall>>=
cumulative <- function(cex.title=1.5, cex.lab=1.5, cex.legend=2, lwd=2, las=0, cex.axis=2, line.xaxis=1)
{
num_rows = ceiling(length(streams)/2)
layout(matrix(1:(2*num_rows), num_rows, 2))
par(mar=c(3,2,1,1)+0.1, oma=c(3,4,1,1))
line_type=1
color=1
yy=c(0,1)
xx = c(0,max(aggregate[aggregate$snow==FALSE,'theisen'], na.rm=T))
for(stream in streams)
{
stream_data = get(stream)
non_snow = stream_data[stream_data$snow==FALSE & !is.na(stream_data$ptot_tot) & !is.na(stream_data$stot_tot),]
non_snow_sorted = non_snow[ order(non_snow$theisen) ,]
sed = cumsum(non_snow_sorted$stot_tot)/sum(stream_data$stot_tot, na.rm=T)
phos = cumsum(non_snow_sorted$ptot_tot)/sum(stream_data$ptot_tot, na.rm=T)
plot( x=non_snow_sorted$theisen, y=sed, type='l',lwd=lwd,
lty=1, col=color, bty='n', ylim=yy, xlim=xx, axes=FALSE)
par(new=T, ann=F)
plot( x=non_snow_sorted$theisen, y=phos, type='l', lwd=lwd,
lty=2, col=color, bty='n', ylim=yy, xlim=xx, axes=FALSE)
legend(x='topleft', bty='n', legend=c("sediment", "phosphorus"), lty=1:2, cex=cex.legend, lwd=lwd)
mtext(stream_names[[stream]], side=3, line=-3, cex=cex.title, at=0.55*xx[2] )
par(new=F, ann=T, xaxt='s', yaxt='s')
axis(side=1, at=seq(xx[1], xx[2], by=2), cex.axis=cex.axis, las=las, mgp=c(3,line.xaxis,0))
axis(side=2, at=c(0, 0.5, 1), cex.axis=cex.axis, las=las)
}
mtext("Theisen rainfall (in)", side=1, line=1, cex=cex.lab, at=NA, outer=TRUE)
mtext("Proportion of total loading", side=2, line=2, cex=cex.lab, at=NA, outer=TRUE)
}
@
<<proportion>>=
q_90 = list()
for(target in c("stot_tot", "ptot_tot"))
{
output = paste(target, "_major", sep="")
q=vector()
for(stream_name in streams){
stream = get(stream_name)
stream[output] <- with(stream, ifelse(get(target)>quantile(get(target), 0.9, na.rm=T),1,0))
stream$major <- with(stream, ifelse(get(target)>quantile(get(target), 0.9, na.rm=T),1,0))
proportion = sum(stream[stream[output]==1,target], na.rm=T)/sum(stream[,target], na.rm=T)
q = c(q, proportion)
assign(stream_name, stream) }
names(q) = streams
q_90[[target]] = q
}
@
<<by_year, eval=FALSE>>=
for (year in unique(bower$water_year))
{
annual = bower[bower$water_year==year,]
major_s <- with(annual, ifelse(get("stot_tot")>quantile(get("stot_tot"), 0.9, na.rm=T),1,0))
major_p <- with(annual, ifelse(get("ptot_tot")>quantile(get("ptot_tot"), 0.9, na.rm=T),1,0))
cat( paste(year, "\n") )
cat( paste("number of events: ", dim(annual)[1], "\n", sep="") )
cat( paste("sediment: total: ", sum(annual$stot_tot), ", rain: ", sum(annual$stot_tot[annual$snow==FALSE]),
", snow: ", sum(annual$stot_tot[annual$snow==TRUE]), "\n") )
cat( paste("proportion of sediment carried by year's biggest events: ",
round(sum(annual$stot_tot[major_s==1], na.rm=T)/sum(annual$stot_tot, na.rm=T), 3), "\n") )
cat( paste("proportion of sediment carried by year's biggest event: ",
round(max(annual$stot_tot, na.rm=T)/sum(annual$stot_tot, na.rm=T), 3), "\n") )
cat( paste("date of biggest sediment event: ",  annual$start_day[which.max(annual$stot_tot)], "\n") )
cat( paste("phosphorus: total: ", sum(annual$ptot_tot), ", rain: ", sum(annual$ptot_tot[annual$snow==FALSE]),
", snow: ", sum(annual$ptot_tot[annual$snow==TRUE]), "\n") )
cat( paste("proportion of phosphorus carried by year's biggest events: ",
round(sum(annual$ptot_tot[major_p==1], na.rm=T)/sum(annual$ptot_tot, na.rm=T), 3), "\n") )
cat( paste("proportion of phosphorus carried by year's biggest event: ",
round(max(annual$ptot_tot, na.rm=T)/sum(annual$ptot_tot, na.rm=T), 3), "\n") )
cat( paste("date of biggest phosphorus event: ",  annual$start_day[which.max(annual$ptot_tot)], "\n") )
}
@
